# 进程 线程
进程是操作系统进行资源分配和调度的基本单位，线程是CPU进行调度和分派的基本单位
## 进程
* 进程有自己的独立地址空间，进程的虚拟内存空间分为内核空间和用户空间。内核空间由高端地址往低端地址发展，存放内核代码和数据，与进程相关的的数据结构（页表，task，内核栈等）。用户空间由低端地址往高端发展，存放进程的代码段和数据段，运行时的堆和用户栈。
* 进程通过fork创建子进程，fork创建子进程时先共享，进行写操作再复制，创建进程时要复制页表结构，文件描述符表，寄存器，进程信息。上下文切换要保存较多数据
* 进程之间的通信通过进程间通信进行
## 线程
* 线程依赖于进程，进程是线程的一个容器，共享线程的地址空间，只拥有少量资源，如程序计数器PC，寄存器，栈，线程id。上下文切换开销要比进程小的多
* 线程通过clone系统调用，轻量级fork，共享页表，打开文件表等资源
* 同一进程下线程共享全局变量，通信容易
* 一个线程崩溃，程序崩溃

# 进程通信
## 管道
* 内核的缓冲区
* 半双工、单向流动
* 适合传输大量信息，发送字节为单位，无格式的字节流
* 父子或兄弟等有亲缘关系
* 只存在内存中的独立文件系统
* 只能从头部读，无法定位查找
* 要保证另一端有进程
## 命名管道
* 多了文件名存在文件系统，非亲缘关系进程访问文件该路径就可通信
## 消息队列
* 克服了信号传递信息少、管道只能承载无格式字节流以及缓冲区大小受限等缺点。和信号相比，消息队列能够传递更多的信息。与管道相比，消息队列提供了有格式的数据，但消息队列仍然有大小限制
* 接收者必须轮询消息队列，才能收到最近的消息
* 取消息进程可以选择接收特定类型的消息，而不是像管道中那样默认全部接收
## 信号
Linux系统响应某些条件而产生的一个事件，事先定义，接受到信号的进程可采取自定义行为。分为硬件来源和软件来源
  * 硬件： ctrl+c、除0、溢出等。硬件异常包装成信号发给进程
  * 软件： kill命令、软件异常产生等
### 进程发信号
  * 操作系统提供发送信号的系统调用
  * 系统调用将信号放入目标进程的信号队列
  * 目标进程处于未执行状态，信号由内核保存，知道进程恢复。信号设置成阻塞要等到阻塞取消才传递
  * 指定目标进程的号码
### 进程收信号
  * 每个进程由一个信号队列
  * 特定时刻检查信号队列并处理。如系统空间返回到用户空间
### 信号处理
  处理、忽略、默认
## 共享内存
多个进程将同一段共享内存映射到自己的地址空间，然后像访问正常内存一样访问它，不涉及内核态和用户态的切换，不需要对数据进行不必要的复制，只拷贝两次：一次从输入文件到共享内存区，另一次从共享内存到输出文件
* 共享内存的缺点是存在并发问题，有可能出现多个进程修改同一块内存，因此共享内存一般与信号量结合使用。
## 信号量
特殊的变量，对它的操作都是原子的
* V（信号）：若有其他进程等待资源被挂起，唤醒它，否则信号量加一
* P（等待）：信号量为0是，进程挂起，否则信号量减一
## 套接字

# IO模型
IO两个阶段：用户进程--内核空间（拷贝），内核空间--设备空间（磁盘、网络等）（数据准备）
## 阻塞IO
应用进程调用--内核等待数据---内核拷贝数据到用户空间--返回指示，应用处理数据
* 进程挂起不消耗CPU资源，及时响应每个操作
* 不适用并发量大
## 非阻塞IO
进程发起IO系统调用，内核数据没准备好，不会阻塞等待，返回一个错误，数据准备好后阻塞等待拷贝
* 进程轮询调用，消耗CPU资源
* 并发量小，不需要及时响应的应用
## IO复用
多个进程的IO注册到复用器select上，一个进程调用select，监听所有IO，一旦有可用数据就返回，阻塞拷贝
* 高并发：一个进程（线程）响应多个请求
* 处理连接数不高，性能可能比多线程+阻塞IO更差
### select、poll、epoll
* select：有最大连接数限制，全平台支持，每次调用select都要把fd集合从用户态拷贝到内核态，返回也要遍历文件描述符表
* poll：和select差不多，描述fd集合的方式不同，无数量限制，IO数量大性能下降
* epoll：使用三个函数，epoll_create创建epoll句柄，epoll_ctl注册监听事件，epoll_wait等待事件发生。在epoll_ctl注册事件时，就会把所有fd拷贝进内核，而不是epoll_wait时重复拷贝，每个fd只会拷贝一次。不用遍历文件描述符，采用回调机制，不会因监视fd数量增加而性能下降
  * LT水平触发：检测到描述符事件发生并通知应用程序，可以不立刻处理，下次调用epoll_wait，会再次响应应用程序并通知
  * ET边缘触发：检测到描述符事件发生并通知应用程序，必须立刻处理，下次调用epoll_wait，不会再次响应应用程序并通知
## 信号驱动IO
进程发起IO操作，向内核注册一个信号处理函数，返回不阻塞，数据准备好后发送信号给进程，拷贝
* 回调机制
* 网络编程很少用，socket相关的读写操作太多（TCP建立断开，数据发送和到达），应该在IO事件单一情况使用
## 异步IO
进程发起IO操作，进程返回不阻塞，也不返回结果，内核处理完整个IO后通知进程直接获取到数据
* 不阻塞，数据一步到位
* 高并发

# 死锁
https://zhuanlan.zhihu.com/p/61221667  
两个以上的并发进程中，每个资源持有某种资源而又在等待其他进程释放它们的资源，在未改变这种状态前不能继续推进（锁，网络连接，通知事件，磁盘，带宽等资源）
## 产生条件
* 互斥：一个资源只能被一个进程使用（如CD-ROM驱动器，打印机等）
* 请求和保持：一个进程至少占有一个资源，并在等待其他进程占用的资源，对已有资源不释放
* 非抢占：不能强制抢占，只能等待进程完成任务后资源释放
* 循环等待：多个进程形成环形等待资源关系
## 处理方法
### 鸵鸟策略
解决死锁代价很高。当死锁不会造成很大影响，或发生概率很低时可以采用
### 死锁预防（静态策略，资源申请）
破坏死锁形成的四个必要条件
* 破坏 互斥  
允许资源被多个进程访问。但有些资源不具备这种属性，实用性很有限
* 破坏 请求和保持
  * 资源预先分配（进程运行前必须一次性申请所有资源，要么运行，要么等待，不会获得资源又要请求）
  * 缺点：无法预知进程所需的全部资源，降低资源利用率（可能资源只使用一次，但全程被占有），降低并发性
* 破坏 非抢占  
持有资源，又有新的请求，且无法满足，释放已有资源，被抢占了。实现困难，降低系统性能
* 破坏 循环等待
给资源编号，进程对资源的请求必须按序号递增来提出，申请了小号资源才能申请大号资源，不会产生环路
  * 跟其他策略比，资源利用率和系统吞吐量都有很大提高
  * 但限制了进程对资源的请求，给资源编号也很困难，增加了系统开销
  * 增加了资源占用时间，可能是要先使用大号资源，小号资源最后才使用
### 死锁避免（动态策略，资源分配）
系统状态分为安全和不安全状态  
安全：系统中所有进程能按照某种次序分配资源，依次运行完毕(能找到安全序列)  
安全状态能避免死锁，不安全可能发生死锁  
银行家算法：对系统资源和进程需求、占有情况进行统计，会产生死锁就不分配（如果剩余资源大于进程还需要的资源，标记进程，之后释放资源，最后未进程
* 比死锁预防限制少
* 必须先声明进程请求的最大资源
* 没法进程同步
### 死锁检测
死锁预防和死锁避免，不利于资源的充分共享
#### 资源分配图无环路，无死锁
有环是死锁充分必要条件
#### 资源分配图有环路
* 每种资源只有一个资源  
检测算法：检测有向图是否有环，从一个节点开始深度搜索，标记访问过的节点，再次访问则有环，死锁发生
* 每种资源有多个资源
有环不一定死锁  
检测算法：类似银行家算法
### 死锁解除
* 抢占
挂起某些进程，抢占资源，分配给其他进程
* 回滚
让某些进程回退到足以解除死锁的状态，需要系统保持进程历史信息，设置还原点
* 杀死进程
  * 杀死所有进程，代价太大
  * 逐个杀死，回收资源重新分配，直到死锁解除（可按照CPU消耗时间最少、产生输出量最小、预计剩余执行时间最长、分得资源最少或优先级最低）