# 页面置换
最佳置换OPT：标记最大的移出，不可能实现，无法知道将来  
先进先出FIFO
最近最久未使用LRU：将过去一段时间近似为将来，选择最近最久没使用  
1、双向链表+字典     2、collections里的OrderedDict 有序字典  
应用：functools.lru_cache 使用缓存  斐波那契
最少使用LFU：数组计数

# python3.6 字典变有序
## 3.6前
初始化一个数组（默认8），存hash值，key，value， 计算hash(key),key要可哈希的（不可变对象），算出来的值%（字典最小长度-1），冲突就向下直到有空位（开放寻址法：线性探测、二次探测、双重探测）  
负载因子超过2/3，要扩容，需要再次全部哈希
## 3.7后  有序
引入索引表存enteies的索引，enteies不再是稀疏的，插入值才存入

# python 新式类
多重继承 广度优先

# 单例模式
1、实例占用资源
2、同步的需要，比如共享文件的控制，计数器
* 模块导入
* __new__函数实现
* 装饰器实现（函数、类）
* 元类

# 元类
所有类都是type派生出来，type是类的元类，自定义元类截获类的创建，加入自定义的东西，再通过type类构造类

# 垃圾回收
## 引用技术：创建、引用、参数传递、存入容器
循环引用问题
## 标记清除（扫描整个堆）
* 维持两个双端链表，先把引用数减一，为零得放入不可达链表，不为零放入可达链表
* 递归遍历可达链表的点，把可到达的拉回可达链表
* 清除不可达链表    

清除过程程序暂停，减少暂停时间，引入分代回收
## 分代回收（空间换时间）
统计发现，对象存在时间越长，越不可能是垃圾
* 年轻代，中年代，老年代，最开始存在年轻代，扫描后进入下一代
* 当新分配的对象数和释放的对象数达到某个阈值，就会触发扫描

# 栈 堆
* 栈向低地址扩展，连续，无需管理
* 堆向高地址扩展，不连续，自己申请

# 赋值  深拷贝 浅拷贝
赋值：对内存地址（引用）的拷贝，两个变量指向同个内存地址，一个变量变了，另一个也会变
浅拷贝：没有拷贝子对象，两个变量指向不同内存地址，改变子对象，两个都会变
深拷贝：包含子对象的拷贝，内存地址不同，原对象改变不会造成深拷贝子对象的改变  
浅拷贝只拷贝顶层引用，深拷贝会逐层进行拷贝，直到拷贝的所有引用都是不可变引用为止。

# 鸭子类型
不管是不是鸭子，看起来是鸭子，它就是鸭子。不关心对象时什么类型，只看方法

# 猴子补丁
 在不宜修改源码的情况下，比如第三方模块修改
# @classmethod @staticmethod
## 实例方法
类中的函数（带self类方法），隐式传递实例对象  
只能实例调用，类调用不行
## 类方法classmethod
隐式传递类对象  
类对象和实例对象都可以调用，构造实例前可以和类交互
## 静态方法staticmethod
不需要传递  
类对象和实例对象都可以调用

# 执行cmd命令
当前进程，阻塞：os.system无返回值，os.popen有返回值  
子进程： subpross.Popen

# 协程
https://www.cnblogs.com/fengf233/p/11548769.html  
https://developer.51cto.com/art/202008/622981.htm  
由于GIL，多线程处理CPU密集型任务很鸡肋，处理IO密集型有用（IO调用会释放GIL），线程是竞争型的，由CPU调度的，控制不容易，执行顺序不确定；协程是协作式的，顺序可以确定     
协程是用户态的轻量级线程（微线程），有自己的寄存器上下文和栈。切换时保存上次调用状态，重入时进入上次调用的状态（进入上一次离开时所处逻辑流位置）  
线程切换不只是上下文，还有每个线程自己的缓存  
线程是CPU给时间片，在不同程序间切换。协程是单一的线程，由程序控制阻塞时切换，保存状态，返回来执行读取保存状态。一个线程，不存在写变量冲突，不用加锁，效率比线程高。  
## 一个线程内状态切换
类似生成器保存状态（yield，send发送值）  
生产者消费者模型：c=comsumer(), producte(c):c.send(None),c.send(n)
## 并发
