# 事务
## 概念
一个操作序列，不可分割的一个工作单位
## 特性 ACID
* 原子性（Atomicity）：不可分割，要么全部成功，要么全部失败回滚
* 一致性（Consistency）：使数据库保持一致性状态（所有事务对一个数据的读取结果都相同）
* 隔离性（isolation）：事务在最终提交前，对其他事务不可见
* 持久性（Durability）：事务提交成功，对数据的修改时永久性的
### ACID关系
一致性保证执行结果正确，持久性应对系统崩溃。无并发时，隔离性一定满足，满足原子性就满足一致性；有并发时，满足原子性和隔离性才能满足一致性
# 并发一致性问题
并发时隔离性很难保证，因此会出现并发一致性问题
## 1、丢失修改
一个事务的更新操作被另一个事务的更新操作替换
## 2、脏读
当前事务可以读到另外事务未提交的数据
## 3、不可重复读
一个事务多次读取同一数据集合，读取结果不一致
## 4、幻读
本质上也是不可重复读，幻读指插入了新数据
# 封锁
## 封锁粒度
MySQL提供两种封锁粒度：行级锁，表级锁  
尽量只锁定需要修改部分，锁定数据量少，发生锁争用就少，系统并发程度就高了  
加锁消耗资源，封锁粒度越小，系统开销越大  
选择封锁粒度需要在锁开销和并发程度间做权衡
## 封锁类型
### 1、读写锁
* 互斥锁：X锁，写锁，可以读取和更新，不能再加锁
* 共享锁：S锁，读锁，可以读，不可以更新，能再加S锁
### 2、意向锁
事务T想对表A加X锁，要先检测是否有其他事务对表A或者表A的任意一行加了锁，所以要对表A的每一行都检测一次，非常耗时  
引入IX/IS锁，都是表锁
* 一个事务在获得某个数据行对象的S锁前，必须获得表的IS锁或更强的锁
* 一个事务在获得某个数据行对象的X锁前，必须获得表的IX锁  

现在，事务T要对表A加X锁，只要检测是否有其他事务对表A加了X/IX/IS锁，加了就表示有其他事务正在使用这个表或者表中的某一行的锁，所以事务T加X锁失败
* IS/IX锁之间兼容，只表示想要对表加锁，并没有真正加锁
* IX和表级X不兼容，和行级X兼容
## 封锁协议
### 1、三级封锁协议
* 一级封锁协议  
修改数据要加X锁，直到事务结束才释放。  
解决丢失修改问题，不能同时有两个事务对同个数据修改，事务的修改就不会被覆盖
* 二级封锁协议  
在一的基础上，读取数据要加S锁，读取结束立刻释放  
解决脏读，一个事务在对数据A进行修改，要加X锁，那就不能再加S锁，不会读到别的事务未提交数据
* 三级封锁协议  
在二的基础上，读取数据要加S锁，知道事务结束了才释放  
解决不可重复读，读数据A时，加了S锁，其他事务不能加X锁，在读期间数据不会改变
### 2、两段锁协议
加锁和解锁分两个阶段进行
# 隔离级别
## 未提交读
事务中的修改，没有提交也对其他事务可见  
没法解决并发一致性问题
## 提交读
事务的修改在提交前对其他事务不可见  
解决脏读
## 可重复读
保证同一事务多次读取同一数据结果是一样的  
解决脏读、不可重复读
## 可串行化
强制事务串行执行，多个事务互不干扰，不会出现并发一致性问题  
解决脏读、不可重复读、幻读
# 多版本并发控制 MVCC
MVCC是MySQL的InnoDB存储引擎实现隔离级别的一种具体方式。可以实现提交读和可重复读两种隔离级别。未提交读总是读取最新的数据行，要求很低，无需使用MVCC。可串行化需要对所有读取行都加锁，单纯用MVCC无法实现
## 基本思想
加锁能够解决多个事务同时执行出现的并发一致性问题。实际场景中读操作往往多于写操作，因此对锁进行细分，引入读写锁来避免不必要的加锁操作，读和读没有互斥关系，读和写互斥。MVCC更进一步，写操作更新最新的版本快照，读操作读取旧版本快照，没有互斥关系。  

事务版本号：事务开始时的系统版本号  
系统版本号：每开始一个事务，系统版本号自动递增  
 
MVCC在每行记录后面都保存有两个隐藏列，用来储存创建版本号和删除版本号  
创建版本号：创建一个数据行时的事务版本号  
删除版本号：删除操作时的事务版本号  
* 插入：记录创建版本号
* 删除：记录删除版本号
* 更新：先记录删除版本号，再记录创建版本号
* 查询：符合条件才能被查询出来：删除版本号未定义或大于当前事务版本号；创建版本号小于或等于当前事务版本号  

## 快照读和当前读
快照读是读取快照中的数据，减少加锁的开销  
当前读读取最新数据，要加锁
# Next-Key Locks
MVCC不能解决幻读的问题，。在可重复读的隔离级别下，MVCC+Next-Key Locks 可以解决幻读问题  
## Record Locks
行锁，锁定索引，而不是记录本身
## Gap Locks
锁定索引间的间隙，但是不包含索引本身
## Next-Key Locks
Record Locks 和 Gap Locks 的结合，锁定一个左开右闭的区间

# 存储过程
事先编译并储存在数据库中得一段SQL语句的集合。想要实现响应功能，只要调用这个存储过程
## 优点
* 预先编译，不需要每次运行时编译，提高执行效率
* 封装了一系列操作，对于一些数据交互比较多的操作，相比于单独执行SQL语句，可以减少网络通信量
* 具有可复用性，减少数据库开发的工作量
* 安全性高，可以让没有权限的用户间接操作数据库
* 更易于维护
## 缺点
* 可移植性差，存储过程将应用程序绑定到数据库上
* 开发调试复杂
* 修改复杂，要重新编译

# 索引
http://blog.codinglabs.org/articles/theory-of-mysql-index.html
